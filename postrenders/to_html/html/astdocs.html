<!DOCTYPE html><html><head><link rel=stylesheet href=style-body.css><link rel=stylesheet href=style-code.css><body><h1 id=module-astdocs>Module <code>astdocs</code></h1><p>Extract and format documentation from <code>Python</code> code.<blockquote><p><em>According to </em><em>my</em><em> standards.</em></blockquote><p>In a few more words, parse the underlying Abstract Syntax Tree (AST) description. (See the <a href=https://docs.python.org/3/library/ast.html>documentation</a> of the standard library module with same name.) It expects a relatively clean input (demonstrated in this very script) which forces <em>me</em> to keep <em>my</em> code somewhat correctly documented and without fancy syntax.<p>My only requirement was to use the <code>Python</code> standard library <strong>exclusively</strong> (even the <a href=https://docs.python.org/3/library/string.html#template-strings>templating</a>) as it is quite [overly] complete these days, and keep it as <em>lean</em> as possible. Support for corner cases is scarse... for one, no class-in- nor function-in-function (which I consider private, in the <code>Python</code> sense).<blockquote><p><em>Use at your own risk.</em></blockquote><p>The simplest way to check by example is to run this script on itself:<div class=codehilite><pre><span></span><code>$ python astdocs.py astdocs.py  <span class=c1># pipe it to your favourite markdown linter</span>
</code></pre></div><p>or even:<div class=codehilite><pre><span></span><code>$ python astdocs.py .  <span class=c1># recursively look for *.py files in the current directory</span>
</code></pre></div><p>The behaviour of this little stunt can be modified via environment variables:<ul><li><code>ASTDOCS_BOUND_OBJECTS</code> taking the <code>1</code>, <code>on</code>, <code>true</code> or <code>yes</code> values (anything else will be ignored/counted as negative) to add <code>%%%START ...</code> and <code>%%%END ...</code> markers to indicate the beginning/end of an object (useful for further styling when rendering in <code>HTML</code> for example).<li><code>ASTDOCS_FOLD_ARGS_AFTER</code> to fold long object (function/method) definitions (many parameters). Defaults to 88 characters, <a href=https://github.com/psf/black><code>black</code></a> <a href=https://www.youtube.com/watch?v=wf-BqAjZb8M&t=260s&ab_channel=PyCon2015>recommended</a> default.<li><code>ASTDOCS_SHOW_PRIVATE</code> taking the <code>1</code>, <code>on</code>, <code>true</code> or <code>yes</code> values (anything else will be ignored) to show <code>Python</code> private objects (which names start with an underscore).<li><code>ASTDOCS_SPLIT_BY</code> taking the <code>m</code>, <code>mc</code>, <code>mfc</code> or an empty value (default, all rendered content in one output): split each <strong>m</strong>odule, <strong>f</strong>unction and/or <strong>c</strong>lass (by adding <code>%%%BEGIN ...</code> markers). Classes will always keep their methods. In case <code>mfc</code> is provided, the module will only keep its docstring, and each function/class/method will be marked.<li><code>ASTDOCS_WITH_LINENOS</code> taking the <code>1</code>, <code>on</code>, <code>true</code> or <code>yes</code> values (anything else will be ignored) to show the line numbers of the object in the code source (to be processed later on by your favourite <code>Markdown</code> renderer). Look for the <code>%%%SOURCE ...</code> markers.</ul><div class=codehilite><pre><span></span><code>$ <span class=nv>ASTDOCS_WITH_LINENOS</span><span class=o>=</span>on python astdocs.py astdocs.py
</code></pre></div><p>or to split marked sections into separate files (in <code>Bash</code> below; see also the <code>Python</code> example in the docstring of the <code>astdocs.render_recursively()</code> function):<div class=codehilite><pre><span></span><code>$ <span class=nv>ASTDOCS_SPLIT_BY</span><span class=o>=</span>mc python astdocs.py module.py <span class=p>|</span> csplit -qz - <span class=s1>'/^%%%BEGIN/'</span> <span class=s1>'{*}'</span>
$ grep -v <span class=s1>'^%%%'</span> xx00 > module.md
$ rm xx00
$ <span class=k>for</span> f <span class=k>in</span> xx??<span class=p>;</span> <span class=k>do</span>
>   <span class=nv>path</span><span class=o>=</span><span class=k>$(</span>grep -m1 <span class=s1>'^%%%BEGIN'</span> <span class=nv>$f</span> <span class=p>|</span> sed -r <span class=s1>'s|%%%.* (.*)|\1|g;s|\.|/|g'</span><span class=k>)</span>
>   mkdir -p <span class=k>$(</span>dirname <span class=nv>$path</span><span class=k>)</span>
>   grep -v <span class=s1>'^%%%BEGIN'</span> <span class=nv>$f</span> > <span class=s2>"</span><span class=nv>$path</span><span class=s2>.md"</span>  <span class=c1># double quotes are needed</span>
>   rm <span class=nv>$f</span>
> <span class=k>done</span>
</code></pre></div><p>Each of these environment variableis translates into a private attribute with the same name: the <code>ASTDOCS_FOLD_ARGS_AFTER</code> value is stored in the <code>_fold_args_after</code> variable for instance.<p>When handling options completely programmatically, this breaks the <code>Python</code> idiomatic ways (code in the middle of <code>import</code> statements):<div class=codehilite><pre><span></span><code><span class=kn>import</span> <span class=nn>os</span>

<span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>"ASTDOCS_FOLD_ARGS_AFTER"</span><span class=p>]</span> <span class=o>=</span> <span class=mi>88</span>
<span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>"ASTDOCS_WITH_LINENOS"</span><span class=p>]</span> <span class=o>=</span> <span class=s2>"off"</span>

<span class=kn>import</span> <span class=nn>astdocs</span>

<span class=n>md</span> <span class=o>=</span> <span class=n>astdocs</span><span class=o>.</span><span class=n>render_recursively</span><span class=p>(</span><span class=s2>"."</span><span class=p>)</span>
</code></pre></div><p>and that might make some checkers/linters unhappy. (This whole thing started with two flags but grew out of hands...)<p><strong>Attributes:</strong><ul><li><code>TPL_CLASSDEF</code> [<code>string.Template</code>]: Template to render <code>class</code> objects.<li><code>TPL_FUNCTIONDEF</code> [<code>string.Template</code>]: Template to render <code>def</code> objects (async or not).<li><code>TPL_MODULE</code> [<code>string.Template</code>]: Template to render the module summary.<li><code>TPL</code> [<code>string.Template</code>]: Template to render the overall page (only governs order of objects in the output).</ul><p><strong>Functions:</strong><ul><li><a href=#astdocsformat_annotation><code>format_annotation()</code></a><li><a href=#astdocsformat_docstring><code>format_docstring()</code></a><li><a href=#astdocsparse_classdef><code>parse_classdef()</code></a><li><a href=#astdocsparse_functiondef><code>parse_functiondef()</code></a><li><a href=#astdocsparse_import><code>parse_import()</code></a><li><a href=#astdocsparse_tree><code>parse_tree()</code></a><li><a href=#astdocsrender_classdef><code>render_classdef()</code></a><li><a href=#astdocsrender_functiondef><code>render_functiondef()</code></a><li><a href=#astdocsrender_module><code>render_module()</code></a><li><a href=#astdocsrender><code>render()</code></a><li><a href=#astdocsrender_recursively><code>render_recursively()</code></a><li><a href=#astdocspostrender><code>postrender()</code></a></ul><h2 id=functions>Functions</h2><h3 id=astdocsformat_annotation><code>astdocs.format_annotation</code></h3><div class=codehilite><pre><span></span><code><span class=n>format_annotation</span><span class=p>(</span>
    <span class=n>a</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>ast</span><span class=o>.</span><span class=n>Attribute</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>Constant</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>List</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>Name</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>Subscript</span><span class=p>],</span> 
    <span class=n>char</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
<span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Format an annotation (object type or decorator).<p>Dive as deep as necessary within the children nodes until reaching the name of the module/attribute objects are annotated after; save the import path on the way. Recursively repeat for complicated object.<p>See the code itself for some line-by-line documentation.<p><strong>Parameters:</strong><ul><li><code>a</code> [<code>typing.Union[ast.Attribute, ast.Constant, ast.List, ast.Name, ast.Subscript]</code>]: The starting node to extract annotation information from.<li><code>char</code> [<code>str</code>]: The additional character to place at the beginning of the annotation; <code>"@"</code> for a decorator, <code>" -> "</code> for a return type, <em>etc.</em> (defaults to empty string).</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: The formatted annotation.</ul><p><strong>Known problems:</strong><ul><li>Does not support <code>lambda</code> functions.</ul><h3 id=astdocsformat_docstring><code>astdocs.format_docstring</code></h3><div class=codehilite><pre><span></span><code><span class=n>format_docstring</span><span class=p>(</span>
    <span class=n>n</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>ast</span><span class=o>.</span><span class=n>AsyncFunctionDef</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>ClassDef</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>Module</span><span class=p>],</span>
<span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Format the object docstring.<p>Expect some stiff <code>NumPy</code>-ish formatting (see <a href=https://numpydoc.readthedocs.io/en/latest/example.html#example>this</a> or <a href=https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html>that</a>). Do try to <strong>type</strong> all your input parameters/returned objects. And use a linter on the output.<p><strong>Parameters:</strong><ul><li><code>n</code> [<code>typing.Union[ast.AsyncFunctionDef, ast.ClassDef, ast.FunctionDef, ast.Module]</code>]: Source node to extract/parse docstring from.</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: The formatted docstring.</ul><p><strong>Notes:</strong><p>If the regular expression solution used here (which works for <em>my</em> needs) does not fulfill your standards, it is pretty easy to clobber it:<div class=codehilite><pre><span></span><code><span class=kn>import</span> <span class=nn>ast</span>
<span class=kn>import</span> <span class=nn>astdocs</span>

<span class=k>def</span> <span class=nf>my_docstring_parser</span><span class=p>(</span><span class=n>docstring</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
    <span class=c1># process docstring</span>
    <span class=k>return</span> <span class=n>string</span>

<span class=k>def</span> <span class=nf>format_docstring</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=n>ast</span><span class=o>.*</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>  <span class=c1># simple wrapper function</span>
    <span class=k>return</span> <span class=n>my_docstring_parser</span><span class=p>(</span><span class=n>ast</span><span class=o>.</span><span class=n>get_docstring</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>

<span class=n>astdocs</span><span class=o>.</span><span class=n>format_docstring</span> <span class=o>=</span> <span class=n>format_docstring</span>

<span class=nb>print</span><span class=p>(</span><span class=n>astdocs</span><span class=o>.</span><span class=n>render</span><span class=p>(</span><span class=o>...</span><span class=p>))</span>
</code></pre></div><p><strong>Known problems:</strong><ul><li>Overall naive and <em>very</em> opinionated (again, for <em>my</em> use).<li>Does not support list in parameter/return entries.</ul><h3 id=astdocsparse_classdef><code>astdocs.parse_classdef</code></h3><div class=codehilite><pre><span></span><code><span class=n>parse_classdef</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>ClassDef</span><span class=p>):</span>
</code></pre></div><p>Parse a <code>class</code> statement.<p><strong>Parameters:</strong><ul><li><code>n</code> [<code>ast.ClassDef</code>]: The node to extract information from.</ul><h3 id=astdocsparse_functiondef><code>astdocs.parse_functiondef</code></h3><div class=codehilite><pre><span></span><code><span class=n>parse_functiondef</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>ast</span><span class=o>.</span><span class=n>AsyncFunctionDef</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>]):</span>
</code></pre></div><p>Parse a <code>def</code> statement.<p><strong>Parameters:</strong><ul><li><code>n</code> [<code>typing.Union[ast.AsyncFunctionDef, ast.FunctionDef]</code>]: The node to extract information from.</ul><h3 id=astdocsparse_import><code>astdocs.parse_import</code></h3><div class=codehilite><pre><span></span><code><span class=n>parse_import</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>ast</span><span class=o>.</span><span class=n>Import</span><span class=p>,</span> <span class=n>ast</span><span class=o>.</span><span class=n>ImportFrom</span><span class=p>]):</span>
</code></pre></div><p>Parse <code>import ... [as ...]</code> and <code>from ... import ... [as ...]</code> statements.<p>The content built by this function is currently <em>not</em> used. This latter is kept in case all the objects (and aliases) accessible within a module is required for a post-processing or some later smart implementations.<p><strong>Parameters:</strong><ul><li><code>n</code> [<code>typing.Union[ast.Import, ast.ImportFrom]</code>]: The node to extract information from.</ul><h3 id=astdocsparse_tree><code>astdocs.parse_tree</code></h3><div class=codehilite><pre><span></span><code><span class=n>parse_tree</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>):</span>
</code></pre></div><p>Recursively traverse the nodes of the abstract syntax tree.<p>The present function calls the formatting function corresponding to the node name (if supported) to parse/format it.<p>Add an <code>.ancestry</code> attribute on each traversed children object containing the complete path to that object. This path is used to identify ownership of objects (function <em>vs.</em> method for instance).<p><strong>Parameters:</strong><ul><li>[<code>n</code>]: Any type of node to extract information from.</ul><h3 id=astdocsrender_classdef><code>astdocs.render_classdef</code></h3><div class=codehilite><pre><span></span><code><span class=n>render_classdef</span><span class=p>(</span><span class=n>filepath</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Render a <code>class</code> object, according to the defined <code>TPL_CLASSDEF</code> template.<p><strong>Parameters:</strong><ul><li><code>filepath</code> [<code>str</code>]: Path to the module (file) defining the object.<li><code>name</code> [<code>str</code>]: The name (full path including all ancestors) of the object to render.</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: <code>Markdown</code>-formatted description of the class object.</ul><h3 id=astdocsrender_functiondef><code>astdocs.render_functiondef</code></h3><div class=codehilite><pre><span></span><code><span class=n>render_functiondef</span><span class=p>(</span><span class=n>filepath</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Render a <code>def</code> object (function or method).<p>Follow the defined <code>TPL_FUNCTIONDEF</code> template.<p><strong>Parameters:</strong><ul><li><code>filepath</code> [<code>str</code>]: Path to the module (file) defining the object.<li><code>name</code> [<code>str</code>]: The name (full path including all ancestors) of the object to render.</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: <code>Markdown</code>-formatted description of the function/method object.</ul><h3 id=astdocsrender_module><code>astdocs.render_module</code></h3><div class=codehilite><pre><span></span><code><span class=n>render_module</span><span class=p>(</span><span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>docstring</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Render a module summary as a <code>Markdown</code> file.<p>Follow the defined <code>TPL_MODULE</code> template.<p><strong>Parameters:</strong><ul><li><code>name</code> [<code>str</code>]: Name of the module being parsed.<li><code>docstring</code> [<code>str</code>]: The docstring of the module itself, if present (defaults to an empty string).</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: <code>Markdown</code>-formatted description of the whole module.</ul><h3 id=astdocsrender><code>astdocs.render</code></h3><div class=codehilite><pre><span></span><code><span class=n>render</span><span class=p>(</span><span class=n>filepath</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>remove_from_path</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Run the whole pipeline (useful wrapper function when this gets used as a module).<p><strong>Parameters:</strong><ul><li><code>filepath</code> [<code>str</code>]: The path to the module to process.<li><code>remove_from_path</code> [<code>str</code>]: Part of the path to be removed. If one is rendering the content of a file buried deep down in a complicated folder tree <em>but</em> does not want this to appear in the ancestry of the module.</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: <code>Markdown</code>-formatted content.</ul><h3 id=astdocsrender_recursively><code>astdocs.render_recursively</code></h3><div class=codehilite><pre><span></span><code><span class=n>render_recursively</span><span class=p>(</span><span class=n>path</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>remove_from_path</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Run pipeline on each <code>Python</code> module found in a folder and its subfolders.<p><strong>Parameters:</strong><ul><li><code>path</code> [<code>str</code>]: The path to the folder to process.<li><code>remove_from_path</code> [<code>str</code>]: Part of the path to be removed.</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: <code>Markdown</code>-formatted content for all <code>Python</code> modules within the path.</ul><p><strong>Example:</strong><div class=codehilite><pre><span></span><code><span class=kn>import</span> <span class=nn>astdocs</span>

<span class=n>output_folder</span> <span class=o>=</span> <span class=s2>"docs"</span>

<span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>astdocs</span><span class=o>.</span><span class=n>render_recursively</span><span class=p>(</span><span class=o>...</span><span class=p>)</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>"</span><span class=se>\n</span><span class=s2>"</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>line</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>"</span><span class=si>%%</span><span class=s2>%BEGIN"</span><span class=p>):</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>output</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
        <span class=k>except</span> <span class=ne>NameError</span><span class=p>:</span>
            <span class=k>pass</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>()[</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>"."</span><span class=p>)</span>
        <span class=n>basename</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>x</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=si>}</span><span class=s2>.md"</span>
        <span class=n>dirname</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>output_folder</span><span class=si>}</span><span class=s2>/"</span> <span class=o>+</span> <span class=s2>"/"</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>x</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
        <span class=n>os</span><span class=o>.</span><span class=n>makedirs</span><span class=p>(</span><span class=n>dirname</span><span class=p>,</span> <span class=n>exist_ok</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>output</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>dirname</span><span class=si>}</span><span class=s2>/</span><span class=si>{</span><span class=n>basename</span><span class=si>}</span><span class=s2>"</span><span class=p>,</span> <span class=s2>"w"</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>output</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>line</span><span class=si>}</span><span class=se>\n</span><span class=s2>"</span><span class=p>)</span>
<span class=k>try</span><span class=p>:</span>
    <span class=n>output</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
<span class=k>except</span> <span class=ne>NameError</span><span class=p>:</span>
    <span class=k>pass</span>
</code></pre></div><h3 id=astdocspostrender><code>astdocs.postrender</code></h3><div class=codehilite><pre><span></span><code><span class=n>postrender</span><span class=p>(</span><span class=n>func</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Callable</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
</code></pre></div><p>Apply a post-rendering function on the output of the decorated function.<p>This can be used to streamline the linting of the output, or immediately convert to <code>HTML</code> for instance.<p><strong>Parameters:</strong><ul><li><code>func</code> [<code>typing.Callable</code>]: The function to apply; should take a <code>str</code> as lone input.</ul><p><strong>Returns:</strong><ul><li>[<code>str</code>]: <code>Markdown</code>-formatted content.</ul><p><strong>Example:</strong><div class=codehilite><pre><span></span><code><span class=kn>import</span> <span class=nn>astdocs</span>

<span class=k>def</span> <span class=nf>extend_that</span><span class=p>(</span><span class=n>md</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
    <span class=c1># process markdown</span>
    <span class=k>return</span> <span class=n>string</span>

<span class=k>def</span> <span class=nf>apply_this</span><span class=p>(</span><span class=n>md</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
    <span class=c1># process markdown</span>
    <span class=k>return</span> <span class=n>string</span>

<span class=nd>@astdocs</span><span class=o>.</span><span class=n>postrender</span><span class=p>(</span><span class=n>extend_that</span><span class=p>)</span>
<span class=nd>@astdocs</span><span class=o>.</span><span class=n>postrender</span><span class=p>(</span><span class=n>apply_this</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>render</span><span class=p>(</span><span class=n>filepath</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>  <span class=c1># simple wrapper function</span>
    <span class=k>return</span> <span class=n>astdocs</span><span class=o>.</span><span class=n>render</span><span class=p>(</span><span class=n>filepath</span><span class=p>)</span>

<span class=nb>print</span><span class=p>(</span><span class=n>render</span><span class=p>(</span><span class=o>...</span><span class=p>))</span>
</code></pre></div>
